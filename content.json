{"meta":{"title":"殇花思密达","subtitle":null,"description":null,"author":"殇 花","url":"https://www.shanghua.live","root":"/"},"pages":[{"title":"tags","date":"2021-06-20T13:27:36.000Z","updated":"2021-06-20T05:27:54.528Z","comments":true,"path":"tags/index.html","permalink":"https://www.shanghua.live/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-06-20T13:28:52.000Z","updated":"2021-06-20T05:29:03.669Z","comments":true,"path":"categories/index.html","permalink":"https://www.shanghua.live/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"TCP和UDP","slug":"计网/TCP和UDP","date":"2021-06-20T17:00:01.000Z","updated":"2021-06-20T13:04:52.298Z","comments":true,"path":"2021/06/21/计网/TCP和UDP/","link":"","permalink":"https://www.shanghua.live/2021/06/21/%E8%AE%A1%E7%BD%91/TCP%E5%92%8CUDP/","excerpt":"","text":"TCP 可靠性 HTTP 协议 1.1 和 2.2 UDP 灵活 HTTP 协议 3.0 UDP 协议UDP 在数据传输，网络控制，音视频，Web 技术UDP （User Datagram Protocol） 目标是在传输层提供直接发送报文（Datagram）的能力 Datagram 是数据传输的最小单位 UDP 协议不会帮助拆分数据，它的目标只有一个，就是发送报文","categories":[],"tags":[{"name":"计网","slug":"计网","permalink":"https://www.shanghua.live/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"TCP-滑动窗口-流速控制","slug":"计网/TCP-滑动窗口-流速控制","date":"2021-06-20T15:53:20.000Z","updated":"2021-06-20T08:53:30.397Z","comments":true,"path":"2021/06/20/计网/TCP-滑动窗口-流速控制/","link":"","permalink":"https://www.shanghua.live/2021/06/20/%E8%AE%A1%E7%BD%91/TCP-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E6%B5%81%E9%80%9F%E6%8E%A7%E5%88%B6/","excerpt":"","text":"!! 此篇博客内容来自 拉勾教育 作为一个传输层协议，最核心的能力是传输，传输需要保证可靠性，还需要控制流速，这两个核心均由滑动窗口提供 请求/响应模型每一个请求收到响应之后，再发送下一个请求，吞吐量会很低。因为这样的设计，会产生网络的空闲时间，说白了，就是浪费带宽。带宽没有用满，意味着可以同时发送更多的请求，接收更多的响应。 一种改进的方式，就是让发送方有请求就发送出去，而不是等待响应。通过这样的处理方式，发送的数据连在了一起，响应的数据也连在了一起，吞吐量就提升了。 排队（Queuing）在这种情况下，我们通常会考虑排队机制 这样做就需要多个队列，我们要将未发送的数据从队列中取出，加入发送中的队列。然后再将发送中的数据，收到 ACK 的部分取出，放入已接收的队列。而发送中的封包，何时收到 ACK 是一件不确定的事情，这样使用队列似乎也有一定的问题。 滑动窗口（Sliding Window） 深绿色代表已经收到 ACK 的段 浅绿色代表发送了，但是没有收到 ACK 的段 白色代表没有发送的段 紫色代表暂时不能发送的段 这个时候滑动窗口可以向右滑动，如下图所示： 重传如果发送过程中，部分数据没能收到 ACK 会怎样呢？这就可能发生重传。如果发生下图这样的情况，段 4 迟迟没有收到 ACK。 这个时候滑动窗口只能右移一个位置，如下图所示： 在这个过程中，如果后来段 4 重传成功（接收到 ACK），那么窗口就会继续右移。如果段 4 发送失败，还是没能收到 ACK，那么接收方也会抛弃段 5、段 6、段 7。这样从段 4 开始之后的数据都需要重发。 快速重传在 TCP 协议中，如果接收方想丢弃某个段，可以选择不发 ACK。发送端超时后，会重发这个 TCP 段。而有时候，接收方希望催促发送方尽快补发某个 TCP 段，这个时候可以使用快速重传能力。例如段 1、段 2、段 4 到了，但是段 3 没有到。 接收方可以发送多次段 3 的 ACK。如果发送方收到多个段 3 的 ACK，就会重发段 3。这个机制称为快速重传。这和超时重发不同，是一种催促的机制。为了不让发送方误以为段 3 已经收到了，在快速重传的情况下，接收方即便收到发来的段 4，依然会发段 3 的 ACK（不发段 4 的 ACK），直到发送方把段 3 重传。 流速控制假设 RTT = 1ms, 带宽是 1mb/s如果窗口大小为 1kb，那么 1ms 可以发送一个 1kb 段数据（含 TCP 头）1s 就可以发送 1mb 的数据，刚好可以将带宽用慢如果 RTT 再慢一些，比如 RTT = 10ms ,这样的设计就只能用完 1/10 的带宽 总结有了窗口，发送方利用滑动窗口算法发送消息；接收方构造缓存区接受消息，并给发送方 ACK 滑动窗口是 TCP 协议控制可靠性的核心，发送方将数据拆包，变成多个分组，然后讲数据放入一个拥有滑动窗口的数组，依次发出，然后遵循，先入先出（FIFO）的顺序单数窗口中的分组会一次性发送。窗口中序号最小的分组如果收到 ACK ，窗口就会发生滑动，如果最小序号的分组长时间没有收到 ACK，就会触发整个窗口的数据重新发送","categories":[],"tags":[{"name":"计网","slug":"计网","permalink":"https://www.shanghua.live/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"TCP-封包-拆包","slug":"计网/TCP-封包-拆包","date":"2021-06-20T13:16:22.000Z","updated":"2021-06-21T08:10:46.472Z","comments":true,"path":"2021/06/20/计网/TCP-封包-拆包/","link":"","permalink":"https://www.shanghua.live/2021/06/20/%E8%AE%A1%E7%BD%91/TCP-%E5%B0%81%E5%8C%85-%E6%8B%86%E5%8C%85/","excerpt":"","text":"TCP 封包 TCP 协议是如何恢复数据的顺序的 ? 拆包和粘包的作用是什么 ? TCP 是一个传输协议，会讲数据进行拆分进行发送，为什么不分批发送？ 为了稳定性，一次性发送的数据越多，出错的概率越大 为了效率，拆分的数据包就能更好的利用这些并行的路径 发送和接受数据都有缓冲区，缓存区是在内存中开辟的一块区域，目的是缓冲 在传输层封包不能太大以缓存区大小为单位 TCP 协议： 会将数据拆分成不超过缓冲区大小的一个个部分 每个部分都有一个独特的名称，叫做 TCP 段（TCP Segment） 拆包：将数据拆分成多个 TCP 段传输 粘包：将多个数据合并成一个 TCP 段发送 TCP SegmentTCP 分组格式示意图 Source Port/DestinationPort 描述的事发送端口号和目标端口号，代表发送数据的应用程序和接受数据的应用程序 Sequence Number 和 Achnowlendgment Number 是保证可靠性的两个关键 Data Offset 是一个偏移量，原因：TCP Header 部分的长度可变，需要一个数值来描述数据从哪个字节开始 Reserved 是很多协议设计会保留的一个区域，用于日后扩展能力 URG/ACK/PSH/PST/SYN/FIN 是几个标志位，用来描述 TCP 段的行为 URG 代表一个紧急数据（比如终结程序） ACK 代表响应 PSH 代表数据的推送，传输数据 SYN 同步请求，申请握手 FIN 终止请求，挥手 这五个标志位一个占一个 bit 可同时使用 Window 也是 TCP 保证稳定性并进行流量控制的工具 Checksum 是校验和，用来校验 TCP 段有没有损坏 Urgent Poninter 指向最后一个紧急数据的序号（Sequece Number） Option 中存储了一些可选字段 MSS （Maxiumun Segment Size）(长度不固定) Padding 存在的意义是因为 Option 的长度不固定，需要 Pading 进行对齐 Sequece Number 和 Achnowlendgment Number拆包：数据被分成很多个部分，部分增加了协议头合并成一个 TCP 段，进行传输TCP 段经过复杂的网络结构，由底层的 IP 协议，负责传输到目的地，然后进行重组 稳定性要求是数据无损地传输（拆包获得的数据，又需要恢复到原来的样子）数据虽然是顺序发送的，但不能保证是顺序接受的发送的每一个 TCP 段都需要有序号 – Sequence Number（Seq） 发送数据的时候，为每一个 TCP 段分配一个自增的 Sequence Number 接受数据的时候，可以通过 Sequence Number 为乱序的 TCP 段进行排序 接收方回复发送方，也需要 seq，而网络的两个终端，去同步一个自增的序号是非常困难的 对于任何一个接收方，如果知道了发送者发送某个 TCP 段时，已经发送了多少个字节的数据，那么就可以确认发送者发送数据的顺序如果接收方也向发送者发送了数据请求，接收方就不知道发送者发送的数据到底对应哪一条自己发送的数据？每一个 TCP 段发送时，发送方已经接受了多少数据 Achnowlendgment（ACK） 无论是 Seq 和 ACK 都是针对 “对方” 而言的 MSS （Maxiumun Sequence Size） 重要的 TCP Header 中的可选择（Options） 可选性控制 TCP 段的大小，它是一个协商字段（Negotiate） 协商是双方都要遵循的标准，配置不能由单方决定，需要双方协商 TCP 段的大小（MSS）涉及发送、接收缓存区的大小设置 双方实际发送接受封包的大小，对拆包和粘包的过程有知道作用 设置的过大会降低性能 用户占用服务器太多的资源，意味着其他的用户就需要等待或者降低他们的服务质量 支持 TCP 协议工作的 IP 协议，工作效率会下降 IP 协议为什么需要拆包呢？ 在网络中，每次传输的数据不能太大，受限于具体的网络传输设备（物理特性） IP 协议拆分太多的封包并没有意义 可能会导致属于同个 TCP 段的封包被不同的网络线传输，加大延迟 拆包需要消耗硬件和计算资源 是不是 MSS 越小越好呢？ MSS 太小的情况，会浪费传输资源（降低吞吐量） 无法获得完美的解决方案需要实验测试她 总结 TCP 协议是如何恢复数据的顺序的，TCP 拆包和粘包的作用是什么 TCP 拆包的作用，将任务拆分处理，降低整体任务出错的概率，以及减小底层网络处理的压力，粘包过程需要保证数据经过网络的传输，又能恢复到原来的数据 需要数学提供保证顺序的理论依据，TCP 利用 （发送字节数，接受字节数）的唯一性来确认封包直接的顺序关系 TODO 本篇文章未完成","categories":[],"tags":[{"name":"计网","slug":"计网","permalink":"https://www.shanghua.live/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"计算机网络入门-TCP/UDP","slug":"计网/计网-入门","date":"2021-06-19T11:23:11.000Z","updated":"2021-06-21T08:11:03.770Z","comments":true,"path":"2021/06/19/计网/计网-入门/","link":"","permalink":"https://www.shanghua.live/2021/06/19/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%BD%91-%E5%85%A5%E9%97%A8/","excerpt":"为什么 TCP 握手三次，挥手却四次","text":"为什么 TCP 握手三次，挥手却四次 TCP 传输层协议，提供给 Host-To-Host 数据的可靠性传输，支持全双工，是一个连接导向的协议这里主要涉及到，主机到主机、连接、会话、双工/单工及可靠性 主机到主机（Host-To-Host）提供的是 Host-To-Host 传输，一台主机通过 TCP 发送数据到另一台主机可以是电脑-手机-平板TCP 协议往上上 应用到应用 (Application-To-Application) 的协议微信的聊天协议想要工作，就需要一个主机到主机的工具互联网协议群（TCP/IP 协议群） graph LR; A[应用层] --&gt; B[传输层] --&gt; C[网络层] --&gt; D[数据链路层] --&gt; E[物理层] 网络层 提供地址到地址的通讯，不负责信号在具体两个设备传递主机到主机为应用提供应用间通讯的能力 连接（Connection）连接数网络行为状态的记录通讯双方的一个约定，目标是让两个在通讯的程序之间产生一个默契，保证两个程序都在线而且尽快的响应对象的请求两个应用会维护一个关联的对象，比如双方 IP 和 端口 是多少？现在发送了多少数据了，状态健康吗，传输速度如何 双工/单工问题 问题名称 概念 需要几条线路 单工 在任何时刻，如果数据只能单向发送 只需 1 条 半双工 在任何时刻数据可以向一个方向传输 也可以在另一个反方向传输，而且交替进行 至少一条 全双工 如果任何时刻数据都可以双向收发 大于 1 条 线路，是一个抽象的概念，你可以并发的处理信号，达到模拟双工的目的TCP 一个双工协议，数据任何时候都可以双向传输客户端和服务的在 TCP 协议中有一个平等的名词 Host（主机） 可靠性 可靠性（数据保证无损传输）如果发送方按照顺序发送，然后数据无序地主网络间传输，就必须有一种算法在接受方将数据恢复原有的顺序 多播情况如果有一个消息到达任何一个接受者，那么所有接受者都必须收到这个消息 TCP 的握手和挥手TCP 是一个连接导向的协议，设计有建立连接（握手）和断开连接（挥手的过程） 如果一个 Host 主动向另一个 Host 发起连接，被称为 SYN （Synchronization），请求同步 如果一个 Host 主动断开请求，称之为 FIN （Finish），请求完成 如果一个 Host 给另一个 Host 发送数据，成为 PSH （Push），数据推送 接收方接受到数据后，都需要给发送方一个 ACK（Acknowledgement） 响应，如果不响应，发送方会以为需要重发请求保持连接的可靠性约束，TCP 协议要保证每一条发出的数据必须给返回 建立连接的过程（三次握手）sequenceDiagram 客户端-&gt;&gt;服务端:1.客户端发送消息给服务端（SYN） [一次握手] note over 服务端: 2. 服务端准备好进行连接 note right of 服务端: [服务端的准备，不算握手] 服务端-&gt;&gt;客户端: 3. 服务端针对客户端的 SYN 给一个 ACK [三四是同时发生的，算一次握手，第二次握手] 服务端-&gt;&gt;客户端: 4. 服务端发送一个 SYN 给客户端 [三四可以合并成一个 SYN-RCVD 作为一条响应] note over 客户端: 5. 客户端准备好进行连接 note left of 客户端: 客户端准备 不算握手 客户端-&gt;&gt;服务端: 6.客户端针对 SYN 给服务端一个 ACK [第三次握手] 为 TCP 协议增加协议头，在协议头中取对个位（bit），其中 SYN，ACK，PSH 都占有一个位 断开连接的过程（四次挥手） 客户端要求断开连接，发送一个断开的请求，这个叫做 （FIN） 服务端收到请求，然后给客户端一个 ACK，作为 FIN 的响应。 不能像握手一样马上穿回 FIN 回去，因为断开连接要处理的问题比较多，比如说客服务的还有发送出去的消息没有得到 ACK；也可能自己有资源要释放，因此不能将两条消息合并。所以客户端经过等待确认可以关闭连接了，再发生一条 FIN 给客户端 sequenceDiagram 客户端-&gt;&gt;服务端: FIN 请求断开连接 服务端-&gt;&gt;客户端: ACK 响应 客户端 FIN note over 服务端: 服务端处理完事情 服务端-&gt;&gt;客户端: FIN 请求断开连接 客户端-&gt;&gt;服务端: ACK 响应 服务端 FIN 总结 TCP 提供连接（Connection），让双法的传输更加的稳定、安全 TCP 没有直接提供会话，因为应用对会话的需求多种多样，比如聊天程序会话会保持双方的聊天记录，电商程序会话会保持购物车、订单一致，所以会话通常在 TCP 连接上进一步封装 TCP 是一个面相连接的协议（Connection-orented Protocol），说的就是 TCP 协议参与的双方（Host）在收发数据之前会先建立连接。 UDP 是一个面向报文（Datagramo-oriented） 的协议双方不需要建立连接，直接传送报文（数据） 最后，连接 u 要消耗更多的资源；比如说，在传输数据前，必须先协商建立连接，因此，不是每种场景都应该用连接导向的协议。比如视频播放的场景，如果使用连接导向的协议，服务端没向客户端推送一帧视频，客户端都要给服务端响应这是不合理的","categories":[],"tags":[{"name":"计网","slug":"计网","permalink":"https://www.shanghua.live/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"mybatis-源码分析","slug":"mybatis/mybatis-源码分析","date":"2020-07-28T00:00:00.000Z","updated":"2021-06-20T05:10:29.862Z","comments":true,"path":"2020/07/28/mybatis/mybatis-源码分析/","link":"","permalink":"https://www.shanghua.live/2020/07/28/mybatis/mybatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"传统 JDBC 的问题","text":"传统 JDBC 的问题 数据库配置信息存在硬编码问题 解决方法: 1,配置文件 频繁创建释放数据库连接 2,数据库连接池 sql、设置参数,获取结果集均存在硬编码问题 ３，配置文件 手动封装返回结果集，比较繁琐 4,反射，内省 自定义持久层框架设计思路 使用端：（项目）：引入自定义持久层的 jar 包 提供了两部分配置信息：数据库配置信息，sql 配置信息：sql 语句，参数类型，返回值类型 使用配置文件提供这两部分信息 sql Ｍ apConfig.xml 存放数据库配置信息，存放 mapper.xml 的全路径 mapper.xml: 存放 sql 配置信息 自定义持久从逛街本身：（工程）：本质就是对 JDBC 代码进行了封装 加载配置文件：根据配置文件的路径，加载配置文件成字符输入流，存储在内存中 创建 Resource 类 方法 InputStream getResourceAsStream(String path) 创建两个 JavaBean:(容器对象)：存放的就是配置文件解析出来的内容 Configuration:核心配置类：存放 sqlMapConfig.xml 解析的内容 MappedStatement：映射配置类：存放 mapper.xml 解析出来的内容 解析配置文件：dom4j 创建一个类：SqlSessionFactoryBuilder 方法: build (InputStream in) 第一 : 使用 dom4j 解析配置文件，将解析出来的内容封装到容器对象中 第二创建 SqlSessionFactory 对象;生产 sqlSession ：会话对象(工厂模式) 创建 SqlSessionFactory 接口实现类 DefaultSqlSessionFactory 第一 openSession():生产 sqlSession 创建 SqlSession 接口及实现类 DefaultSqlSession 定义对数据库的 crud 操作：selectList(),selectOne(),update(),delete() 创建 Executor 接口及实现类 SimpleExecutor query(Configuration,MappedStatement,Object…params) 执行的就是 JDBC 代码","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.shanghua.live/tags/Mybatis/"}]},{"title":"mybatis-源码学习","slug":"mybatis/mybatis-源码学习","date":"2020-07-26T00:00:00.000Z","updated":"2021-06-20T05:10:29.989Z","comments":true,"path":"2020/07/26/mybatis/mybatis-源码学习/","link":"","permalink":"https://www.shanghua.live/2020/07/26/mybatis/mybatis-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/","excerpt":"传统 JDBC 弊端","text":"传统 JDBC 弊端 JDBC 底层没有用连接池,操作数据库需要频繁创建和关联链接.消耗很大的资源. 原生 jdbc 代码在 java 中,一旦我们需要修改 sql 的话,java 需要整体编译,不利于系统维护. 使用 PreparedStatement 预编译的话对变量进行设置 123 数字,这样的序号不利于维护. 返回 result 结果集也需要硬编码. mybatis 配置方式 使用 xml 方式并不需要创建 Mapper Class 文件 使用 注解方式需要创建 Mapper Class 文件 mybatis 核心概念 名称 意义 Configuration 管理 mysql-config.xml 全局配置关系类 SqlSessionFactory Session 管理工厂接口 Session SqlSession 是一个面向用户（程序员）的接口。SqlSession 提供了很多操作数据库的方法 Executor 执行其是一个接口（基于执行器、缓存执行器）作用: SqlSession 内部通过执行器操作数据库 MappendStatement 底层封装对象 作用: 对操作数据库存储封装,包括 sql 语句、输入输出 StatementHandler 具体操作数据库相关的 handler 接口 ResultSetHandler 具体操作数据库返回结果的 handler 接口","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.shanghua.live/tags/Mybatis/"}]},{"title":"vim 入门","slug":"Linux/vim-入门","date":"2020-07-24T00:00:00.000Z","updated":"2021-06-20T05:12:40.753Z","comments":true,"path":"2020/07/24/Linux/vim-入门/","link":"","permalink":"https://www.shanghua.live/2020/07/24/Linux/vim-%E5%85%A5%E9%97%A8/","excerpt":"vim 常用快捷键移动光标","text":"vim 常用快捷键移动光标 h j k l 控制上下作用,也可以使用方向键 ctrl + b 屏幕往后移动一页 f 屏幕往前移动一页 u 屏幕往后移动半页 d 屏幕往前移动半页 shift + g == G 移动文章到最后 4 == $ 移动到所在行的行尾 6 == ^ 移动到光标所在行首 w 光标跳到下一个单词开头 e 光标跳到下一个单词的词尾 b 光标回到上个字的开头 :1 跳到第数字行 gg 进入到文本的开始 常用命令 :nu 显示当前行数 :set nu 显示所有行数 :set expandtab tab 为 4 个空格 :set autoindent 保持当前缩进 复制粘贴 yy 复制光标当前行 p 粘贴到当前光标下一行","categories":[],"tags":[{"name":"Vim","slug":"Vim","permalink":"https://www.shanghua.live/tags/Vim/"}]},{"title":"maven-入门","slug":"maven/maven-入门","date":"2020-07-20T00:00:00.000Z","updated":"2021-06-20T05:10:44.642Z","comments":true,"path":"2020/07/20/maven/maven-入门/","link":"","permalink":"https://www.shanghua.live/2020/07/20/maven/maven-%E5%85%A5%E9%97%A8/","excerpt":"maven 使用简介","text":"maven 使用简介 maven 使用,在项目目录创建 pom.xml 文件,格式是 12345678910111213141516&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.wang&lt;/groupId&gt; &lt;artifactId&gt;shanghua-maven&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; maven 使用一种约定大于配置的模式,所以项目必须严格按照 maven 的约定进行开发 maven 目录结构 src/main/java 内放如 java 源代码 src/main/resource 资源目录 src/test pom.xml maven 文件 maven 常用命令 mvn clean 清楚打包内容 mvn compile 编译项目 maven 测试 测试文件必须放入到 src/test/java,类名以 Test 开头,方法名以 test 开头 执行 mvn test 即可 执行所以 test 开头方法 编译好的 test 文件 在 target/test-classes 下 测试结果在 target/surefire-reports 下 使用 junit 进行测试,在 pom.xml 内加入 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 加入后必须在需要执行的方法上加上 @Test 注解才会运行 maven 仓库 本地仓库 可通过修改本地 maven 配置文件 settings.xml &lt;localRepository&gt; 修改仓库目录 远程仓库可通过添加 mirror 节点添加. maven 项目依赖 依赖一个框架的时候,会同时依赖此项目的所以依赖 依赖优先原则 下方的依赖会覆盖上方的依赖 相同路径下的,配置在前优先 依赖范围 &lt;scope&gt; 配置在 &lt;dependency&gt; 下限制依赖范围 compile: 默认,编译范围,编译和打包都会依赖 provided:提供范围,编译时依赖,但不会打包进去,如 server-api.jar runtime: 运行时范围,打包时依赖,编译不会,如 mysql-connector.jar test: 测试范围,运行测试用例依赖,如 junit.jar, test jar 包只有 src/test 内的文件才能引用 system: 表示由系统中的 CLASSPATH 指定,编译时依赖,不会打包进去,配合 &lt;systemPath&gt; 一起使用,如 java.home 下的 tool.jar maven 依赖管理 父类内可声明 &lt;dependencyManagement&gt; 内部可写 &lt;dependencies&gt; 子类依赖父类后,并不会直接依赖父类 &lt;dependencyManagement&gt; 内声明的内容,只有声明后才会依赖,依赖可省略版本号 maven 默认属性 $&#123;basedir&#125; 项目根目录 $&#123;version&#125; 项目版本 $&#123;project.basedir&#125; 同 $&#123;basedir&#125; $&#123;project.version&#125; 同 $&#123;version&#125; $&#123;project.build.directory&#125; 构建目录,缺省为 target $&#123;project.build.sourcceEncoding&#125; 表示主源码的编码格式 $&#123;project.build.sourceDirectory&#125; 表示主源码路径 $&#123;project.build.finalName&#125; 表示输出文件名称 $&#123;project.build.outputDirectory&#125; 构建过程输出目录,缺省 target/classes 默认属性可在 resource 目录下配置文件 以及 pom.xml 内使用, 属性还可以通过 执行 mvn 命令是加入 -D 参数添加 项目生命周期123graph LRA[预编译] --&gt;B[编译] --&gt; C[编译测试类] --&gt; D[构建] --&gt; G[jar 包构建] --&gt; F[部署]D --&gt; H[war 包构建] --&gt; F[部署] maven 生命周期 clean : 清理生命周期,用于清理项目 default:默认生命周期,用于编译,打包,测试,部署等 site: 站点文档生成,用于构建站点文档 当执行下面生命周期的目录时,会将上方的生命周期走一边 maven 生命周期命令大部分是由插件完成的,例如 test 就是由 maven-surefire-plugin","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"https://www.shanghua.live/tags/Maven/"}]},{"title":"maven-插件","slug":"maven/maven-插件","date":"2020-07-20T00:00:00.000Z","updated":"2021-06-20T05:10:44.547Z","comments":true,"path":"2020/07/20/maven/maven-插件/","link":"","permalink":"https://www.shanghua.live/2020/07/20/maven/maven-%E6%8F%92%E4%BB%B6/","excerpt":"maven 命令 mvn dependency:tree 可查看插件的依赖关系","text":"maven 命令 mvn dependency:tree 可查看插件的依赖关系 mvn archetype:generate 使用 maven 生成项目 mvn help:effective-pom maven 插件绑定 生命周期的阶段可以绑定具体的插件及目标 不同配置下同一阶段可以对应多个插件和目标 maven 绑定插件的目录在 MAVEN_HOME\\lib\\maven-core.jar\\META-INF\\plexus\\default-bindings.xml maven 插件使用示例 123456789101112131415161718192021222324&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;!-- 在执行 package后 将依赖复制到 $&#123;project.build.directory&#125;/alternateLocation 目录下--&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.2&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-dependencies&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;!-- 指定 goal 执行位置--&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;!-- 指定配置文件--&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/alternateLocation&lt;/outputDirectory&gt; &lt;overWriteReleases&gt;false&lt;/overWriteReleases&gt; &lt;overWriteSnapshots&gt;false&lt;/overWriteSnapshots&gt; &lt;overWriteIfNewer&gt;true&lt;/overWriteIfNewer&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 插件使用第二种方法 mvn groupId:artifactId:version:goal -D{参数名} 插件开发流程 创建 maven 插件项目 设定 packaging 为 maven-plugin 添加插件依赖 编写插件实现逻辑 打包构建插件 插件 pom 配置 创建 maven 项目 定义&lt;packaging&gt;maven-plugin&lt;/packaging&gt; 引入 maven-plugin-api maven-plugin-annotations 依赖 插件方法类继承 org.apache.maven.plugin.AbstractMojo 实现 execute 方法 可在全局变量上方加上 org.apache.maven.plugins.annotations.Parameter 注解,获取 maven 参数 maven nexus 私服 搭建完成后可通过添加 repositories 制定 maven 服务器 也可通过修改 maven setting.xml 中的 mirrors 全局指定服务器 如需要 deploy jar 包到私服,需要在 pom.xml 下的 distributionManagement 下制定私服地址,并在 setting.xml 文件下添加 server 节点添加用户获取权限,并且 server 下的 id 需要与 distributionManagement 下的 id 对应","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"https://www.shanghua.live/tags/Maven/"}]},{"title":"git-入门","slug":"Git/git-入门","date":"2020-07-17T00:00:00.000Z","updated":"2021-06-20T05:11:51.904Z","comments":true,"path":"2020/07/17/Git/git-入门/","link":"","permalink":"https://www.shanghua.live/2020/07/17/Git/git-%E5%85%A5%E9%97%A8/","excerpt":"git 存储文件时候会将一个文件存储到一个数据库中","text":"git 存储文件时候会将一个文件存储到一个数据库中 git 常用命令 git init ./目录名 初始化，初始化后会创建一个 .git 文件夹 元数据存储在 objects 中 git add 将文件存储到暂存取 -A 将所有文件存储到暂存取 git rm –cached 将文件从暂存区删除，本地文件并不会被删除 git commit filename -m ‘first commit’ 将暂存区文件提交到本地仓库 git push -u origin master 将本地仓库提交到远程仓库 master git config –list 查看 git 配置环境 git show 查看最后一次提交 git 分支相关命令 git branch 默认查看分支 -avv 查看所有分支 -d 删除分支 git branch 分支名 父分支名 创建一个分支 git gc 当强制删除一个分支的时候，分支内的信息还是存在的，通过这个命令可打包项目信息，跳过删除的信息 git 解决冲突 当远程仓库内容被修改，pull 的时候由于本地仓库与远程仓库文件冲突，会进入到一个解决冲突的分支，需要解决冲突后，重新执行 add commit push 操作解决冲突 git 远程仓库 git remote add origin url 指定远程仓库 git remote add origin2 url 添加远程仓库 git remote origin set-url url 修改远程地址 git remote temove 分支名 删除远程仓库 git push –set-upstream origin master 上传至远程分支 git branch –track git tag git tag 查看当前 tag git tag tag 名 创建 tag git 日志管理 git log 查看日志 –oneline 简单查看 –graph 图形网络 git log 分支名 查看某个分支的日志 git log dev..master 查看多少个 master 没有提交到 dev 内 git 底层原理 git 存储对象(hashMap) find .git/objects/ -type f 查找所有 git 对象 git hash-object -w filename 存储一个文件，并返回 hash，相当与 git add git cat-file -p hash 通过 hash 查看文件内容，我们并不知道文件内容属于哪个文件 git cat-file -p master^{tree} 查看一个提交的文件的信息，包含文件名 git commit 提交会包含一个 commit 对象，对象包含一个文件对象，包含文件名以及对应的 keycommit 对象 还包含一个 src 树对象 书对象包含 层级目录对象，直至目录中的文件，文件包含文件名以及 key 通过 git log 可查看 commit 对象包含的 keygit cat-file -p key 可查看 commit 包含的内容内容包含一个 tree 对象以及一个树对象一个新 commit 产生的时候 改变的文件会将 上级的 key 改变 直到 commit key git 创建中央仓库 git init –bare shanghua.git 创建裸项目，只要能访问这个目录就能进行开发，甚至是共享文件夹 git clone root@ip:项目目录 通过这条命令可访问上一条命令在远程仓库创建的项目，通过 ssh 协议搭建 中央仓库 通过 nginx 搭建 http 中央仓库 http(dump) 协议 1234567server&#123; listen 80; server_name git.shanghua.com; location / &#123; root /data/git-repository; # 仓库地址 &#125;&#125; 重命名钩子mv hooks/post-update.sample hooks/post-update 本地克隆 git clone http://git.shanghua.com/shanghua.git 通过 git 协议搭建远程仓库 git 协议 123nohup git daemon --reuseaddr --base-path=&#x27;项目目录&#x27; &#x27;项目目录&#x27;默认端口是 9418git clone git://ip:9418/shanghua.git shanghua git 服务器搭建git gogs 服务器 gogs 官网 https://gogs.io/ 下载安装包 解压进入 gogs 目录 ./gogs web 即可运行 浏览器访问本地 ip:3000 即可初始化项目 gogs 可配置 邮箱服务器 gogs 备份 ./gogs backup -h 查看备份相关参数 ./gogs backup 默认备份,备份在当前目录 ./gogs backup –target=’输出目录’ –database-only –exclude-repos ./gogs restore –from=’备份文件’ 备份恢复","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.shanghua.live/tags/git/"}]},{"title":"IDEA 破解教程","slug":"Java/idea-破解","date":"2020-05-08T10:38:00.000Z","updated":"2021-06-20T05:09:17.259Z","comments":true,"path":"2020/05/08/Java/idea-破解/","link":"","permalink":"https://www.shanghua.live/2020/05/08/Java/idea-%E7%A0%B4%E8%A7%A3/","excerpt":"下载破解 jar 包 下载地址 下载后解压","text":"下载破解 jar 包 下载地址 下载后解压 打开 IDEA 在试用模式下点击 Help –&gt; Edit Custom VM Option 第一次点击会让创建一个文件，点击确定 在最后一行加入 -javaagent:你解压后jar包的位置 重启 IDEA IDEA 启动后点击 Help –&gt; Register –&gt; License server 在 Server address 内输入 http://fls.jetbrains-agent.com 点击 ACTIVATE 成功后点击 CONTINUE DONE 使用方法来自 https://zhile.io/2018/08/25/jetbrains-license-server-crack.html","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://www.shanghua.live/tags/IDEA/"}]},{"title":"可转债","slug":"股市/可转债","date":"2020-04-28T20:16:00.000Z","updated":"2021-06-20T05:12:09.575Z","comments":true,"path":"2020/04/29/股市/可转债/","link":"","permalink":"https://www.shanghua.live/2020/04/29/%E8%82%A1%E5%B8%82/%E5%8F%AF%E8%BD%AC%E5%80%BA/","excerpt":"打新可转债 判断新债 https://www.jisilu.cn/data/cbnew/#pre","text":"打新可转债 判断新债 https://www.jisilu.cn/data/cbnew/#pre 先价比转股甲 先价比转股价 &gt; 95% 评级 AA、AA+、AAA 可转债说明可转换是一张可以转化成股票的公司债券 可转债 债券 在可转债到期后公司需要连本带息还钱 100￥ + 利息 &gt; 100￥ 在 &lt; 100人民币 买入可保本 可转换为股票 可转债会随着股票的价格增长而增长 尽可能购买评级高的股票 防御性买入法（慢） 买入价格 &lt; 100￥ 评级 AA 级以上 进攻型买入法（快） 溢价率低于 20% 上市满足半年 价格低于 110 评级至少为 至少AA 怎么卖 上涨不卖 最高点 跌 10 元卖出","categories":[],"tags":[]},{"title":"elasticsearch 与 Head 插件","slug":"other/elasticsearch","date":"2020-04-08T00:00:00.000Z","updated":"2021-06-20T05:13:06.480Z","comments":true,"path":"2020/04/08/other/elasticsearch/","link":"","permalink":"https://www.shanghua.live/2020/04/08/other/elasticsearch/","excerpt":"","text":"基础命令 查询 进入 Head 插件 复合查询 http://localhost:9200/ _analyze POST Body &#123;&quot;analyzer&quot;:&quot;ik_smart&quot;,&quot;text&quot;:&quot;php java&quot;&#125;","categories":[],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://www.shanghua.live/tags/elasticsearch/"}]},{"title":"MongoDB 的安装和使用","slug":"other/MongoDB","date":"2020-04-03T15:44:15.000Z","updated":"2021-06-20T05:13:06.830Z","comments":true,"path":"2020/04/03/other/MongoDB/","link":"","permalink":"https://www.shanghua.live/2020/04/03/other/MongoDB/","excerpt":"安装 MongoDB 进入到 https://www.mongodb.com/download-center/community 即可选择符合你操作系统的安装包 按照安装包指示的流程安装即可 安装完成后将安装后的 bin 目录加入到系统 path 环境变量中","text":"安装 MongoDB 进入到 https://www.mongodb.com/download-center/community 即可选择符合你操作系统的安装包 按照安装包指示的流程安装即可 安装完成后将安装后的 bin 目录加入到系统 path 环境变量中 使用 MongoDB 创建目录 打开命令提示符 创建存放数据的目录 md d:\\data 启动服务 mongod ‐‐dbpath=d:\\data 连接 mongo 192.168.184.134 常用命令 创建数据库 use 数据库名 数据库不存在则会自动创建 use spit 插入数据 db.数据库名.insert(数据); db.spit.insert(&#123;content:&quot;aaa&quot;,userid:&quot;1011&quot;,nickname:&quot;小雅&quot;,visits:NumberInt(902)&#125;); 查询数据 db.集合名称.find(); db.spit.find(); 可以发现，每个数据库文档都会自动创建一个 _id 字段，相当于数据库的主键，我们可以插入支持的类型值替换 db.spit.insert(&#123;_id:&quot;1&quot;,content:&quot;aaa&quot;,userid:&quot;1012&quot;,nickname:&quot;小明&quot;,visits:NumberInt(2020)&#125;); 条件查询 db.spit.find(&#123;userid:&#39;1011&#39;&#125;) 查询一个 db.spit.findOne(&#123;userid:&#39;1013&#39;&#125;) 指定条数 db.spit.find().limit(3) 修改数据 db.集合名称.update(条件,修改后的数据) 修改 _id 为 1 的记录 db.spit.update(&#123;_id:&quot;1&quot;&#125;,&#123;visits:NumberInt(1000)&#125;) 修改后除了 visits 字段其他字段都不见了，我们可以使用 $set 解决 db.spit.update(&#123;_id:&quot;2&quot;&#125;,&#123;$set:&#123;visits:NumberInt(2000)&#125;&#125;) 删除数据 db.集合名称.remove(条件) 入过没条件则全部删除 慎用！ db.集合名称.remove(&#123;visits:1000&#125;) 删除 visits 为 100 的值 统计条数 db.spit.count() db.spit.count(&#123;userid:&quot;1012&quot;&#125;) 统计 userid 为 1012 的数量\\ 模糊查询 /模糊查询字符串/ db.spit.find(&#123;content:/流量/&#125;) db.spit.find(&#123;content:/^加班/&#125;) 大于 小于 不等于 db.集合名称.find(&#123; &quot;field&quot; : &#123; $gt: value &#125;&#125;) // 大于: field &gt; value db.集合名称.find(&#123; &quot;field&quot; : &#123; $lt: value &#125;&#125;) // 小于: field &lt; value db.集合名称.find(&#123; &quot;field&quot; : &#123; $gte: value &#125;&#125;) // 大于等于: field &gt;= value db.集合名称.find(&#123; &quot;field&quot; : &#123; $lte: value &#125;&#125;) // 小于等于: field &lt;= value db.集合名称.find(&#123; &quot;field&quot; : &#123; $ne: value &#125;&#125;) // 不等于: field != value 包含与不包含 db.spit.find(&#123;userid:&#123;$in:[&quot;1013&quot;,&quot;1014&quot;]&#125;&#125;) 查询 useid 字段包含 1013 和 1014 的文档 db.spit.find(&#123;userid:&#123;$nin:[&quot;1013&quot;,&quot;1014&quot;]&#125;&#125;) 查询 useid 字段不包含 1013 和 1014 的文档 条件连接 $and:[ &#123; &#125;,&#123; &#125;,&#123; &#125; ] 相当于 SQL 中的 AND db.spit.find(&#123;$and:[ &#123;visits:&#123;$gte:1000&#125;&#125; ,&#123;visits:&#123;$lt:2000&#125; &#125;]&#125;) 查询 visits 大于 1000 并且小于 2000 的文档 $or:[ &#123; &#125;,&#123; &#125;,&#123; &#125; ] 相当于 SQL 中的 OR db.spit.find(&#123;$or:[ &#123;userid:&#123;$gte:&quot;1013&quot;&#125;&#125; ,&#123;visits:&#123;$lt:2000&#125; &#125;]&#125;) 查询 userid 等于 1013 并且 visits 小于 2000 的文档 列值增长 db.spit.update(&#123;_id:&quot;2&quot;&#125;,&#123;$inc:&#123;visits:NumberInt(1)&#125;&#125;)","categories":[],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://www.shanghua.live/tags/MongoDB/"}]},{"title":"K8s(kubernetes) 简介","slug":"other/k8sAbout","date":"2020-03-30T20:50:23.000Z","updated":"2021-06-20T05:13:06.663Z","comments":true,"path":"2020/03/31/other/k8sAbout/","link":"","permalink":"https://www.shanghua.live/2020/03/31/other/k8sAbout/","excerpt":"kubernetes容器编排工具，是一个开源的平台，可以实现容器集群的自动化部署，自动扩缩容，维护等功能","text":"kubernetes容器编排工具，是一个开源的平台，可以实现容器集群的自动化部署，自动扩缩容，维护等功能 快速部署应用 快速扩展应用 无缝对接新的应用功能 节省资源，优化硬件资源应用 特点 可移植 支持公有云（阿里云，腾讯云），私有云（OpenStack），混合云，多重云（多个公有云） 可扩展 模块化，插件化，可挂载，可组合 自动化 自动部署，自动重启，自动复制，自动伸缩/扩展 kubernetes 的目标是促进完善组件和工具的生态系统，已减轻应用程序在公有云或私有云运行的负担","categories":[],"tags":[{"name":"k8","slug":"k8","permalink":"https://www.shanghua.live/tags/k8/"}]},{"title":"使用 SSH 连接 Ubuntu","slug":"Linux/ubuntu-ssh","date":"2020-03-30T20:27:22.000Z","updated":"2021-06-20T05:11:39.044Z","comments":true,"path":"2020/03/31/Linux/ubuntu-ssh/","link":"","permalink":"https://www.shanghua.live/2020/03/31/Linux/ubuntu-ssh/","excerpt":"软件准备FinalShell 软件官网 http://www.hostbuf.com/ 因为我们之前安装系统的时候已经安装过 SSH 了，这里我们直接连接就好了","text":"软件准备FinalShell 软件官网 http://www.hostbuf.com/ 因为我们之前安装系统的时候已经安装过 SSH 了，这里我们直接连接就好了 第一步查看 IP 地址，在命令行输入 ifconfig 123456789shanghua@ubuntu:~$ ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.1.103 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::20c:29ff:fe32:75e2 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:32:75:e2 txqueuelen 1000 (Ethernet) RX packets 29766 bytes 43406394 (43.4 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 3187 bytes 257063 (257.0 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 这里我的 IP 地址就是 192.168.1.103 打开 FinalShell 并新建一个连接 点击确定，这样我们就连接成功了 12345连接成功To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.See &quot;man sudo_root&quot; for details.shanghua@ubuntu:~$ 这里我们就获得了一个 shell 就可以直接操作虚拟机里的系统了 设置 ROOT 用户12345shanghua@ubuntu:~$ sudo passwd root[sudo] password for shanghua:Enter new UNIX password:Retype new UNIX password:passwd: password updated successfully 先输入当前用户密码，然后再输入两次 ROOT 账户密码，这样就设置成功了 切换到 ROOT 用户123shanghua@ubuntu:~$ suPassword:root@ubuntu:/home/shanghua# 我们输入 su 命令，然后再输入我们刚刚设置的 ROOT 密码就可以切换到 ROOT 用户了，我们可以从命令行看到，用户从 shanghua 变成了 root 配置 SSH 允许 ROOT 用户远程连接1root@ubuntu:/home/shanghua# vi /etc/ssh/sshd_config 12#PermitRootLogin prohibit-passwordPermitRootLogin yes 修改 SSH 配置文件，将 PermitRootLogin 后面的 prohibit-password 修改为 yes 重启 SSH 服务1root@ubuntu:/home/shanghua# service ssh restart 重启后 ssh 配置文件才会生效哦 编辑 FinalShell 连接改为 root 用户 记得改密码哦，修改完成点击确定，然后打开这个连接 12连接成功root@ubuntu:~# 这样就会发现连接上后就是 root 用户了","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.shanghua.live/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.shanghua.live/tags/Ubuntu/"}]},{"title":"python 换源","slug":"Python/python换源","date":"2020-03-30T20:27:21.000Z","updated":"2021-06-20T05:12:32.389Z","comments":true,"path":"2020/03/31/Python/python换源/","link":"","permalink":"https://www.shanghua.live/2020/03/31/Python/python%E6%8D%A2%E6%BA%90/","excerpt":"环境 平台 Windows 10python 3","text":"环境 平台 Windows 10python 3 临时换源1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 永久换源在 %HOMEPATH%\\pip 目录下新建 pip.ini 文件，内容如下(如果没有 pip 文件夹，新建一个即可 ) 1234[global]timeout = 6000index-url = https://mirrors.aliyun.com/pypi/simple/trusted-host = mirrors.aliyun.com","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.shanghua.live/tags/Python/"}]},{"title":"java - 算法","slug":"Java/java-算法","date":"2020-03-30T20:27:15.000Z","updated":"2021-06-20T05:09:18.567Z","comments":true,"path":"2020/03/31/Java/java-算法/","link":"","permalink":"https://www.shanghua.live/2020/03/31/Java/java-%E7%AE%97%E6%B3%95/","excerpt":"排序算法分类 计算复杂度：最佳、最坏以及平均复杂度","text":"排序算法分类 计算复杂度：最佳、最坏以及平均复杂度 内存使用：空间复杂度 递归算法：排序算法中是否用到了递归 稳定性：当相同的健存在时，经过排序后，其值也保持相对的顺序（不发生变化） 比较排序：集合中的两个元素比较排序 串行或并行：是否运用串行或并行排序 时间复杂度表达式（Time Complexity） 表达式：Big O notation 常量时间：T(n) = O(1)(数组随机访问) 线性时间：T(n) = O(n)(在未排序数组中找最值) 对数时间：T(n) = O(n)(二级制搜索) 指数时间：T(n) = O(n^c)(冒泡排序、插入排序) 比较排序 冒泡排序(Bubble Sort)：最佳 O(n)、平均 O(n^2)、最坏 O(n^2) 插入排序(Insertion Sort)：最佳 O(n)、平均 O(n^2)、最坏 O(n^2) 快速排序(Quick Sort)：最佳 O(nlogn)、平均 O(nlong)、最坏 O(n^2) 合并排序(Merge Sort)：最佳 O(nlogn)、平均 O(nlong)、最坏 O(nlong) Tim 排序(Tim Sort)：最佳 O(n)、平均 O(nlong)、最坏 O(nlong) 内建实现 冒泡排序(Bubble Sort)：无 插入排序(Insertion Sort)：java.util.Arrays#megeSort （当排序集合数量小于 7 时） 快速排序(Quick Sort)：java.util.DualPivotQuicksort#sort（Since 1.7） 合并排序(Merge Sort)：java.util.Arrays#megeSort （1.7 之后需要激活） Tim 排序(Tim Sort)：java.util.TimSort （Since 1.7）","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://www.shanghua.live/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"java 面向对象设计二","slug":"Java/java 面向对象设计二","date":"2020-03-30T20:27:00.000Z","updated":"2021-06-20T05:09:17.375Z","comments":true,"path":"2020/03/31/Java/java 面向对象设计二/","link":"","permalink":"https://www.shanghua.live/2020/03/31/Java/java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%BA%8C/","excerpt":"Java 泛型设计泛型使用场景 编译时强类型转换 避免类型强转 实现通用算法","text":"Java 泛型设计泛型使用场景 编译时强类型转换 避免类型强转 实现通用算法 泛型类型A generic type is a generic class or interface that is parameterized over types. 调用泛型类型 实例化泛型 java 7 Diamond 类型参数命名约定 类型参数命名约定 E: 表示集合元素（Element） V: 表示数值（Value） K: 表示键（Key） T: 表示类型 可以参考 java.util.function.BiConsumer 类的写法 泛型有界类型参数 单界限 多界限 泛型方法和有界类型参数","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"}]},{"title":"java 函数式设计","slug":"Java/java-函数式设计","date":"2020-03-30T20:27:00.000Z","updated":"2021-06-20T05:09:17.859Z","comments":true,"path":"2020/03/31/Java/java-函数式设计/","link":"","permalink":"https://www.shanghua.live/2020/03/31/Java/java-%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AE%BE%E8%AE%A1/","excerpt":"@Functionallnterface用于函数式接口类型声明的信息注解类型，这些接口的实例被 Lambda 表示式、方法引用或构造器引用创建。函数时接口只能有一个抽象方法，","text":"@Functionallnterface用于函数式接口类型声明的信息注解类型，这些接口的实例被 Lambda 表示式、方法引用或构造器引用创建。函数时接口只能有一个抽象方法，并排除默认方法以及声明中覆盖 Object 的公开方法的统计。同时 @Functionallnterface 不能标注在注解，类以及枚举上。如果违背以上规则，那么接口不能视为函数式接口，当标注 @Functionallnterface 后，会引起编译错误。 不过，如果任意接口满足以上函数式接口的要求，无论接口生命中是否标注 @Functionallnterface ，均能被编译器视作函数式接口。 函数式接口类型 提供类型 - Supplier&lt;T&gt; 消费类型 - Consumer&lt;T&gt; 转换类型 - Function&lt;T,R&gt; 断定类型 - Predicate&lt;T&gt; 隐藏类型 - Action 函数式接口设计Supplier&lt;T&gt; 接口定义 基本特点：只进不出 编程范式：作为方法/构造参数，方法的返回值 使用场景：数据来源，代码替代接口 Function&lt;T,R&gt; 接口定义 基本特点：有进有出 编程范式：作为方法/构造器参数 使用场景：类型转换、业务处理 Predicate&lt;T&gt; 接口定义 基本特点：boolean 类型判断 编程范式：作为方法/构造参数 使用场景：过滤、对象比较等 Stream API 设计Stream 基本操作 转换：Stream#map(Function) 过滤：Stream#filter(Predicate) 排序 Stream#sorted() Stream#sorted(Comparator) Stream 高级操作 Collect 操作 分组操作 聚合操作 flatMap 操作 reduce 操作 Stream 类型 串行 Stream（默认类型） 并行 Stream 转换并行 Stream：Stream#parallel() 是否并行 Stream：Stream#isParallel()","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"}]},{"title":"java 并发理论基础","slug":"Java/java-并发理论基础","date":"2020-03-30T20:27:00.000Z","updated":"2021-06-20T05:09:17.488Z","comments":true,"path":"2020/03/31/Java/java-并发理论基础/","link":"","permalink":"https://www.shanghua.live/2020/03/31/Java/java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/","excerpt":"同步实现 信号量 (Semaphores)：Linux、Solaris 屏障（Barriers）：Linux、Pthreads","text":"同步实现 信号量 (Semaphores)：Linux、Solaris 屏障（Barriers）：Linux、Pthreads 互斥（Mutex）：Linux、Pthreads 条件变量（Condition Variables）：Solaris、Pthreads 自旋锁（Spinlock）：Windows、Linux、Pthreads 读-写锁（Reader-Writer Lock）：Linux、Solaris、Pthreads 同步原语 - synchronized 锁定对象：对象（Object）和类（Class） 修饰范围：方法（Method）、代码块（Block） 特点：重进入（Reentrant） 方法 flages：ACC_SYNCHRONIZED 字节码：monitorenter 和 monitorexit 锁实现：Thin Lock、Inflated、HeavyWeight 实战演示 Java 线程死锁（Dead Lock） Java 线程集合（Starvation）","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"}]},{"title":"java 模块化设计","slug":"Java/java-模块化设计","date":"2020-03-30T20:27:00.000Z","updated":"2021-06-20T05:09:18.488Z","comments":true,"path":"2020/03/31/Java/java-模块化设计/","link":"","permalink":"https://www.shanghua.live/2020/03/31/Java/java-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1/","excerpt":"java -verbose:class Java Compact 模块路径模块路径可能是单个 artiface，或者是多个 artiface 的目录，存在于宿主机器上。","text":"java -verbose:class Java Compact 模块路径模块路径可能是单个 artiface，或者是多个 artiface 的目录，存在于宿主机器上。 类路径（Class Path）的脆弱性 通过 artifaces 的 Class Path 区分类型 无法区分 artifaces 无法提前通知 artifaces 缺少 允许不同的 artifaces 定义在相同的 packages 定义类型 模块路径的差异性 定位整个模块而非类型 无论是运行时，还是编译时，在同一个目录下不允许出现同名模块 可读性（Readability）模块 com.foo.app 依赖 模块 com.foo.bar 和 java.sql，说明 java.sql 对 com.foo.app 是可读的。同时，java.sql 依赖 java.xml 和 java.logging 模块，然而这并不意味着 java.xml 或 java.logging 对 com.foo.app 可读。简言之，可读性无法跨层模块之家生效 Java 模块化迁移 非命名模块（Unnamed moudule） 类型加载于 ClassPath，而非具体模块，如遗留 jar 文件，暴露所有的 packages。 命名模块（Named modules） 所有正常的 Java 模块，packages 暴露受限于 exports – 自动模块（automatic module） 假设我们需要使用 Spring ListenableFuture API，它来自于 org.springframework:spring-core，由于该 jar 文件属于非命名模块，并且其 artifactid 为 spring-core，该 ID 命名的方式对于模块化名词是非法的。 我们能够在模块路径下能后使用”自动模块”替代 spring-core-*.jar 即使有 spring.core 模块 迁移分析 需要明确应用实现依赖的 JDK 模块 需要明确二方或三方 jar 所依赖的 JDK 模块 需要微服务化应用 迁移建议 凡是定义 module-info.java(module-info.class) 属于命名模块（java 9 + 模块化 artiface） java 9 之前的 artiface 属于命名模块 自动化模块 如果在 MANIFEST.MF 定义了 Automatic-Module-Name 属性，那么采用该属性值作为模块名称 否则，使用 jar 文件的名称(如果存在 “-“ 将其替换为”.”) Java 模块反射获取模块 获取模块 - Class#getModule() 模块接口 - Module 模块描述文件接口 - ModuleDescriptor","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"}]},{"title":"java 面向对象设计一","slug":"Java/java-面向对象设计一","date":"2020-03-30T20:27:00.000Z","updated":"2021-06-20T05:09:18.234Z","comments":true,"path":"2020/03/31/Java/java-面向对象设计一/","link":"","permalink":"https://www.shanghua.live/2020/03/31/Java/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B8%80/","excerpt":"Java 接口设计通用设计","text":"Java 接口设计通用设计 类/接口名 模式：（形容词） + 名词 举例 单名词：java.lang.String 双名词：java.util.ArrayList 形容词+名词：java.util.LinkedList 可访问性 public：开放 API 使用场景 举例：java.lang.String (默认)：仅在当前 package 下使用，属于私有 API 举例：java.io.FileSystem 四种修饰符 public (default) protected : 不能用于修饰最外层 class private : 不能用于修饰最外层 class 可继承性 final：final 不具备继承性，仅用于实现类，不能与 abstract 关键字同时修饰类 举例：java.lang.String 非 final：最常见/默认的设计手段，可继承性依赖于可访问性 举例：java.io.FileSystem 具体类设计常见场景 功能组件 HashMap 接口/抽象类实现 HashMap &lt;- AbstractMap &lt;- Map 数据对象 POJO 工具辅助 *Utils ViewHelper Helper 命名模式 前缀模式：”Default”、”Generic”、”Common”、”Basic” 后缀模式：”impl” 抽象类设计抽象类常见场景 接口通用实现（模板模式） Spring *Template AbstractList AbstractSet AbstractMap 状态/行为继承 工具类 常见模式 抽象程序介于类与接口之间（java 8+ 可完全由接口替换） 以 “Abstract” 或 “Base” 类名前缀 java.util.AbstractCollection javax.sql.rowset.BaseRowSet 接口设计接口设计常见场景 上下游系统（组件）通讯契约 API RPC 常量定义 Serializable Cloneable AutoCloseable EventListener 接口设计常见模式 无状态（Stateless） 完全抽象（&lt; Java 8） 局部抽象（Java 8+） 单一抽象（Java 8 函数式接口） 内置类设计内置类常见场景 临时数据存储类：java.lang.ThreadLocal.ThreadMap 特殊用途的 API 实现：java.util.Collection.UnmodifiableCollection Builder 模式（接口）：java.util.stream.Stream.Builder Java 枚举设计“枚举类” 枚举(enum)实际是 final class， 枚举(成员)修饰符为 public static final values 是 java 编译器做的字节码提升 场景：Java 枚举（enum）引入之前的模拟枚举实现类 模式： 成员用常量表示，并且类型为当前类型 常用关键字 final 修饰 非 public 构造器 枚举基本特性 类结构（强类型） 继承 java.lang.Enum 不可显示地继承和被继承","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"}]},{"title":"进程-线程-协程","slug":"Java/进程-线程-协程","date":"2020-03-30T20:27:00.000Z","updated":"2021-06-20T05:11:08.745Z","comments":true,"path":"2020/03/31/Java/进程-线程-协程/","link":"","permalink":"https://www.shanghua.live/2020/03/31/Java/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B/","excerpt":"进程指计算机中已运行的程序。进程为曾经是分时系统的基本运作单位。在面向进程设计的系统中，进程是程序的基本执行实体；在面向线程设计的系统中，进程本身不是基本运行单位，而是线程的容器。程序本身只是指令、数据以及其组织形式的描述，进程才是程序的真正运行实例","text":"进程指计算机中已运行的程序。进程为曾经是分时系统的基本运作单位。在面向进程设计的系统中，进程是程序的基本执行实体；在面向线程设计的系统中，进程本身不是基本运行单位，而是线程的容器。程序本身只是指令、数据以及其组织形式的描述，进程才是程序的真正运行实例 线程操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程的实际操作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程可以并发多个线程，每条线程并行执行不同的任务。在Unix System V 及 SunOS 中也被称为轻量进程，但轻量进程更多指内核线程，而把用户线程称为线程 Java 线程Green Thread （绿色线程）java 1.2 之前的 Java Thread 实现，模拟多线程并发 Native OS Thread （原生 OS 线程）java 1.2 之后 Java Thread 实现，基于 OS 线程实现，数量映射 1:1 Java 线程编程模型 &lt; Java 5：Thread、Runnable Java 5：Executor、Future、Callable Java 7：ForkJoin Java 8：CompletionStage、CompletableFuture Java 9：Flow（Publisher、Subscriber、Subscription、Processor） Java 线程池 &lt; Java 5：自定义 Thread Pool Java 5+：ExecutorService ThreadPoolExecutor ScheduledThreadPoolExecutor Java 7+ ForkJoinPool Java 并发框架 Java 5：Java Util Concurrent Java 7：Fork/Join Java 8：CompletabFuture、RxJava、Reactor Java 9：Flow API、Reactive Streams 同步最常见的编程手段，是指任务发起和执行方在同一线程完成 异步常见的提升吞吐手段，是指任务发起方和执行方在不同线程中完成 非阻塞一种编程模型，由通知状态被动的回调执行，同步或异步执行均可 POSIX 线程POSIX 线程（英文：POSIX Threads，常被缩写为 Pthreads）是 POSIX 的线程标准，定义了创建和操纵线程的一套 API 实现 POSIX 线程标准的库常被称作 Pthreads，一般用于 Unix-like POSIX 系统，如 Linux Solaris。但是 Microsoft Windows 上的实现也存在，例如直接使用 Windows API 实现的第三方库 pthreads-w32；而利用 Windows 的 SFU/SUA 子系统，则可以直接使用微软提供的一部分原生 POSIX API - https://sourceware.org/pthreads-win32/ Java 线程状态API - java.lang.Thread.State（Since 1.5） NEW：线程已创建，尚未启动 RUNNABLE：表示线程处于可运行状态，不代表一定运行 BLOCKED：被 Monitor 锁阻塞，表示当前线程在同步锁的场景运作 WAITTING：线程处于等待状态，由 Object#wait()、Thread#join() 或 LockSupport#park() TIMED_WAITTING：线程处于规定时间内的等待状态 TERMINATED：线程执行结束 使用场景线程堆栈 工具 - jstack JMX - java.lang.management.ThreadMXBean#dumpAllThreads(boolean,boolean) API - java.lang.Thread#dumpStack() 生命周期方法 启动 - java.lang.Thread#start() 停止 - java.lang.Thread#stop() 暂停 - java.lang.Thread#suspend() 恢复 - java.lang.Thread#resume() “中止” - java.lang.Thread#interrupt()、java.lang.Thread#isInterrupted()","categories":[],"tags":[]},{"title":"Java 进程管理","slug":"Java/java-进程管理","date":"2020-03-30T20:26:00.000Z","updated":"2021-06-20T05:09:18.156Z","comments":true,"path":"2020/03/31/Java/java-进程管理/","link":"","permalink":"https://www.shanghua.live/2020/03/31/Java/java-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"管理当前 JVM 进程 获取当前 JVM 进程 ID 获取当前 JVM 进程启动时间","text":"管理当前 JVM 进程 获取当前 JVM 进程 ID 获取当前 JVM 进程启动时间 获取当前 JVM 进程线程数量 获取当前 JVM 内存使用情况 退出当前 JVM 进程 管理子进程 启动子进程 进程 API 主子进程 I/O 交互 阻塞进程 退出进程","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"}]},{"title":"java 集合便利实现","slug":"Java/java-集合便利实现","date":"2020-03-30T20:26:00.000Z","updated":"2021-06-20T05:09:17.970Z","comments":true,"path":"2020/03/31/Java/java-集合便利实现/","link":"","permalink":"https://www.shanghua.live/2020/03/31/Java/java-%E9%9B%86%E5%90%88%E4%BE%BF%E5%88%A9%E5%AE%9E%E7%8E%B0/","excerpt":"接口类型 单例集合接口（Collections.singleton*） 空集合接口（Collections.empty*） 转换集合接口（Collections.*、Arrays.*） 列举集合接口（*.of(…)）","text":"接口类型 单例集合接口（Collections.singleton*） 空集合接口（Collections.empty*） 转换集合接口（Collections.*、Arrays.*） 列举集合接口（*.of(…)） 单例集合接口 List: Collections.singletonList(T) Set: Collections.singleton(T) Map: Collections.singletonMap(K,V) 设计原则：不变集合（Immutable Collection）空集合接口（Collections.empty*） 枚举：Collections.emptyEnumeration() 迭代器：emptyIterator()、emptyListIterator() List：emptyList() Set：emptySet()、emptySortedSet、emptyNavigableSet() Map：emptyMap、emptySortedMap、emptyNavigableSet() 转换集合接口（Collections.*、Arrays.*） Enumeration：Collections.enumeration(Collection) List: Collections.list(Enumeration&lt;T&gt;)、Arrays.asList(T…) Set：Collections.newSetFromMap(Map&lt;E,Boolean&gt;) Queue：Collections.asLifoQueue(Deque&lt;T&gt;) HashCode：Arrays.hashCode(…) String：Arrays.toString(…) 列举集合接口 (*.of(…)) java.util.BitSet.valueOf(…) java.util.EnumSet.valueOf(…)(Since 1.5) java.util.Stream.valueOf(…) (Since 1.8) java.util.List.valueOf(…) (Since 9) java.util.Set.valueOf(…) (Since 9) java.util.Map.valueOf(…) (Since 9) 包装接口类型 同步包装接口（java.util.Collections.synchronized*） 只读包装接口（java.util.Collections.unmodifiable*) 类型安全包装接口（java.util.Collections.checked*） JAVA 集合 特殊实现 基本介绍为特殊场景设计实现，这些实现表现出非标准性能特性，使用限制或行为。 示例说明 弱引用 Map java.util.WeakHashMap java.lang.ThreadLocal.ThreadLocalMap 对象鉴定 Map java.util.identityHashMap","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"}]},{"title":"java 集合框架基础","slug":"Java/java-集合框架基础","date":"2020-03-30T20:26:00.000Z","updated":"2021-06-20T05:09:18.051Z","comments":true,"path":"2020/03/31/Java/java-集合框架基础/","link":"","permalink":"https://www.shanghua.live/2020/03/31/Java/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/","excerpt":"基本组成 Collection interfaces（集合接口）","text":"基本组成 Collection interfaces（集合接口） Infrastructure（基础设施） General-purppose implementations（通用实现） Abstract implementations（抽象实现） Legacy implementations（遗留实现） Convenience implementations（便利实现） Wrapper implementations（包装实现） Special-purpose implementations（特殊实现） Array Utilities（数组工具类） java.utils.Collection 接口通用接口 java.util.List java.util.Set java.util.SortedSet java.util.NavigableSet(since java 1.6) 集合实现遗留实现 java.util.Vector java.util.Stack java.util.HashTable java.util.En","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"}]},{"title":"Java 并发锁","slug":"Java/java-并发锁","date":"2019-09-18T11:57:00.000Z","updated":"2021-06-20T05:09:17.610Z","comments":true,"path":"2019/09/18/Java/java-并发锁/","link":"","permalink":"https://www.shanghua.live/2019/09/18/Java/java-%E5%B9%B6%E5%8F%91%E9%94%81/","excerpt":"","text":"并发锁 重进入锁 - ReentrantLock 重进入读写锁 - ReentrantReadWriteLock 邮票锁 - StampedLock","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"}]},{"title":"java 函数式基础","slug":"Java/java-函数式基础","date":"2019-08-29T11:40:00.000Z","updated":"2021-06-20T05:09:17.738Z","comments":true,"path":"2019/08/29/Java/java-函数式基础/","link":"","permalink":"https://www.shanghua.live/2019/08/29/Java/java-%E5%87%BD%E6%95%B0%E5%BC%8F%E5%9F%BA%E7%A1%80/","excerpt":"匿名内部类使用场景Java 作为一门面向对象的静态语言，其封装性能够屏蔽数据结构的细","text":"匿名内部类使用场景Java 作为一门面向对象的静态语言，其封装性能够屏蔽数据结构的细 节，从而更加关注模块的功能性。其静态性也确保了 Java 强类型的特性。随着模块功能的提升，伴随而来的是复杂度的增加，代码的语义清晰依赖与开发人员抽象和命名类的或方法的能力。尽管编程思想和设计模式能够促使编程风格趋于统一，然而大多数业务系统属于面共享过程的方式，这与面向对象编程在一定程度上存在一些冲突。Java 编程语言为了解决这个问题，引入了匿名内部类的方案。 匿名内置类基本特性 无名词类 声明位置（执行模块）： static block 实例 block 方法 构造器 并非特殊类 类名称：${package}.${declared_class}.${num}.class 基本特点 基于多态（多数基于接口编程） 实现类无需名称 允许多个抽象方法 编程局限 代码臃肿 强类型约束 接口方法升级","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"}]},{"title":"java 模块化基础","slug":"Java/java-模块化基础","date":"2019-08-22T12:04:00.000Z","updated":"2021-06-20T05:09:18.401Z","comments":true,"path":"2019/08/22/Java/java-模块化基础/","link":"","permalink":"https://www.shanghua.live/2019/08/22/Java/java-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%9F%BA%E7%A1%80/","excerpt":"Java 9 模块化收益 提升平台伸缩性 提升平台完整性","text":"Java 9 模块化收益 提升平台伸缩性 提升平台完整性 提升性能 模块化强封装性 并非所有 public class 都可以被运用，需要 exports 来配合 exports 所配置的 package 下必须要有 Class 负面问题 对人的要求很高（对 Class 透明化） 必须了解相关的 module-info.java 需要了解某些类的依赖 需要了解某些类的职责 个人观点 收益不大，代价不小 对团队要求极高，容易出现互喷的情况 java 9 之前采用 jar 文件管理，java 9 模块化之后，变成了 module-info.java 管理，还需要考虑与 Maven 依赖管理如何配合","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"}]},{"title":"java 面向过程","slug":"Java/java-面向过程","date":"2019-08-22T12:04:00.000Z","updated":"2021-06-20T05:09:18.333Z","comments":true,"path":"2019/08/22/Java/java-面向过程/","link":"","permalink":"https://www.shanghua.live/2019/08/22/Java/java-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/","excerpt":"核心要素 数据结构：原生类型、对象类型、数组类型、集合类型","text":"核心要素 数据结构：原生类型、对象类型、数组类型、集合类型 方法调用：访问性、返回类型、方法参数、异常等 执行流程：赋值、逻辑、迭代（循环）、递归等JAVA 中只有原生类型、对象类型 面向对象基本特性 封装性 派生性 多态性 面向对象设计模式 GOF 23：构建、结构、行为 方法设计：名称、访问性、参数、返回类型、异常 泛型设计：类级别、方法级别 异常设计：层次性、传播性 方法设计 单元：一个类或者一组类（组件） 类采用名词结构 动词过去式+名词 ContextRefreshedEven 动词 ing+名词 linitializingBean 形容词+名称 ConfigurableApplicationContext 执行：某个方法 方法命名：动词 execute callback run 方法参数：名词 异常： 根（顶层）异常 Throwable check 类型：Execption uncheck 类型：RuntimeException 不常见：Error java 1.4 java.lang.StackTraceElement 添加异常的原因（cause） 反模式：吞掉某个异常 性能：注意 fillInStackTrace() 方法开销,避免异常咱掉的深度 方法 1：JVM 参数控制栈深度（物理屏蔽） 方法 2：logback 日志框架控制堆栈输出深度（逻辑屏蔽） 泛型设计java 泛型属于编译时处理，运行时擦写。如果确认了泛型的类型，则用 T，否则用 ?","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"}]},{"title":"JsonSon 实体类与 json 字符串不匹配","slug":"Java/json2Pojo","date":"2019-08-21T23:07:15.000Z","updated":"2021-06-20T05:09:18.633Z","comments":true,"path":"2019/08/22/Java/json2Pojo/","link":"","permalink":"https://www.shanghua.live/2019/08/22/Java/json2Pojo/","excerpt":"字段名与属性名不匹配","text":"字段名与属性名不匹配 在字段上加 JsonProperty 注解 value 对应 json 字符串 12@JsonProperty(value = &quot;isebookon&quot;)private Integer ebookon; 类字段缺少 json 字符串对应的列在类上添加 @JsonIgnoreProperties 注解 12@JsonIgnoreProperties(ignoreUnknown = true)public class TbUser&#123;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"},{"name":"Json","slug":"Json","permalink":"https://www.shanghua.live/tags/Json/"}]},{"title":"Lambda 表达式","slug":"Java/lambda","date":"2019-08-21T23:07:00.000Z","updated":"2021-06-20T05:12:17.304Z","comments":true,"path":"2019/08/22/Java/lambda/","link":"","permalink":"https://www.shanghua.live/2019/08/22/Java/lambda/","excerpt":"基本特点 流程编排清晰 函数类型编程","text":"基本特点 流程编排清晰 函数类型编程 改善代码臃肿 兼容接口升级 编程局限Contents 单一抽象方法 Lambda 调试苦难 Stream API 操作能力有限 函数式接口基本特性 所有函数式接口都引用一段执行代码 函数式接口没有固定的类型，固定模式(SCFP = Supplier + Consumer + Function + Predicate) + Action 利用方法引用来实现模型匹配","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"}]},{"title":"Ubuntu Server 18.04 X64 安装","slug":"Linux/Ubuntu-install","date":"2019-08-21T22:50:24.000Z","updated":"2021-06-20T05:11:38.603Z","comments":true,"path":"2019/08/22/Linux/Ubuntu-install/","link":"","permalink":"https://www.shanghua.live/2019/08/22/Linux/Ubuntu-install/","excerpt":"安装准备","text":"安装准备 1.Ubuntu 镜像准备，下载地址 这里使用的是阿里镜像站的镜像地址 开始安装选择语言 直接回车，选择 English 选择键盘布局 这里直接默认 Done 选择系统类型选择系统类型，第一个是安装 Ubuntu 另外两个是附带云功能的，我们不需要 直接回车，选择第一个 选择网卡我这里是 ens33，其他电脑可能有不同，不过都是 en 开头的 直接回车 选择 IP 代理 这里直接回车，不用填 选择镜像地址 这里我们可以输入阿里云镜像地址，这样后面下载东西会快很多 1http://mirrors.aliyun.com/ubuntu/ 把默认值删掉，输入阿里地址。输入后变成这样 Done 下一步 文件系统设置 这里一定要选择第二个，带 LVM （逻辑卷管理） 的，回车 选择安装磁盘 只有一个，直接回车下一步 磁盘分区，这里需要注意一下 这里有一个 14.996G free space，这怎么行，我们选择 ubuntu-lv 回车选择 Edit 然后将其改为 18.996G，也就是 max 后面的值 然后选择 save 回车，然后我们就会发现 free space 没得了，完美 然后 done 回车，这时候会弹出一个框，我们选择 continue 即可 填写用户名密码 填写完成，shanghua 是我的网名 这里密码一定要记住，不然忘记了就完蛋了 SSH 设置 这里按一下空格选中安装 SSH 服务 Done 不知道是什么页面 不用管直接 Done 最后然后等一小会就会出来这个页面 这里选择 Reboot Now 重启就完成了，重启就进入系统了","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.shanghua.live/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.shanghua.live/tags/Ubuntu/"}]}],"categories":[],"tags":[{"name":"计网","slug":"计网","permalink":"https://www.shanghua.live/tags/%E8%AE%A1%E7%BD%91/"},{"name":"Java","slug":"Java","permalink":"https://www.shanghua.live/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.shanghua.live/tags/Mybatis/"},{"name":"Vim","slug":"Vim","permalink":"https://www.shanghua.live/tags/Vim/"},{"name":"Maven","slug":"Maven","permalink":"https://www.shanghua.live/tags/Maven/"},{"name":"git","slug":"git","permalink":"https://www.shanghua.live/tags/git/"},{"name":"IDEA","slug":"IDEA","permalink":"https://www.shanghua.live/tags/IDEA/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://www.shanghua.live/tags/elasticsearch/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://www.shanghua.live/tags/MongoDB/"},{"name":"k8","slug":"k8","permalink":"https://www.shanghua.live/tags/k8/"},{"name":"Linux","slug":"Linux","permalink":"https://www.shanghua.live/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.shanghua.live/tags/Ubuntu/"},{"name":"Python","slug":"Python","permalink":"https://www.shanghua.live/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://www.shanghua.live/tags/%E7%AE%97%E6%B3%95/"},{"name":"Json","slug":"Json","permalink":"https://www.shanghua.live/tags/Json/"}]}